1 tcp_abort_on_overflow
It decides when the accept queue is full, that is the server does not call
"accept" in time, whether it will sent "rst" to the client.

tcp_check_req
--->tcp_v4_syn_recv_sock
    --->sk_acceptq_is_full (return NULL)
    	---> <sysctl_tcp_abort_on_overflow == 0>
		Y---> inet_rsk(req)->acked = 1
		N---> tcp_v4_send_reset
	
2 tcp_adv_win_scale
static inline int tcp_win_from_space(int space)
{
        return sysctl_tcp_adv_win_scale<=0 ?
                (space>>(-sysctl_tcp_adv_win_scale)) :
                space - (space>>sysctl_tcp_adv_win_scale);
}  

The percentage of buffer reserved for user application / claimed window to the
peer.

F.e, sysctl_tcp_adv_win_scale = 2,
it means we reserve 1/4 rcv_buf for user application async read,
and other 3/4 rcv_buf we can claim via window to the peer.

3 tcp_allowed_congestion_control
It shows the congestion control modules which are built into kernel and
allowed.

4 tcp_app_win
It specifies how much of the buffer space to reserve for the specific window.

5 tcp_autocorking
tcp_sendmsg()-->tcp_push()-->tcp_should_autocork()-->sysctl_tcp_autocorking
It tells whether we should automatically cork the tcp segments since there are
some segments already in qdisc or nic queues.

6 tcp_available_congestion_control
It shows the congestion control modules which are already registered. 

7 tcp_base_mss
/* The least MTU to use for probing */
#define TCP_BASE_MSS            512

8 tcp_challenge_ack_limit


9 tcp_congestion_control
Show / modify the current congestion control algorithm.

10 tcp_dsack
This option decides whether we support dsack function,
1 : enable
0 : disable

11 tcp_early_retrans
	0 disables ER
	1 enables ER
	2 enables ER but delays fast recovery and fast retransmit
	  by a fourth of RTT.
	  This mitigates connection falsely
	  recovers when network has a small degree of reordering
	  (less than 3 packets).
	3 enables delayed ER and TLP.
	4 enables TLP only.
	Default: 3

12 tcp_ecn
default value for tcp: 2
If its value is 1, it will send ECN enable options in SYN packet.

tcp flags layout
|               |
|---------------|
|C|E|U|A|P|R|S|F|
|---------------|
|7   5   3     0| 

a) way handshakes if we set tcp_ecn with 1
A                                        B
---> SYN (CWR=1, ECE=1)
		SYN+ACK (CWR=0,ECE=1)<---
---> ACK (CWR=0, ECE=0)

#define TCP_ECN_OK              1
#define TCP_ECN_QUEUE_CWR       2	/*	tell peer we have handled cwr	*/
#define TCP_ECN_DEMAND_CWR      4	/*	require peer to handle cwr	*/
#define TCP_ECN_SEEN            8

enum {           
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,	/*	it means ip ecn function works	*/
	INET_ECN_CE = 3,	/*	router set it, and tcp get it from ip tos */
	INET_ECN_MASK = 3,
};       

b) tcp get ip tos
int tcp_v4_rcv(struct sk_buff *skb)
-->TCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);

ecn handle

router find congestion
IP_ECN_set_ce
--> iph->tos |= INET_ECN_CE

tcp_event_data_recv/tcp_data_queue_ofo (A)
-->tcp_ecn_check_ce
	-->__tcp_ecn_check_ce
		--> switch (TCP_SKB_CB(skb)->ip_dsfield & INET_ECN_MASK)
			case INET_ECN_CE:
			tp->ecn_flags |= TCP_ECN_DEMAND_CWR | TCP_ECN_SEEN;

tcp_transmit_skb (A)
-->tcp_ecn_send
	--> INET_ECN_xmit
		--> inet_sk(sk)->tos |= INET_ECN_ECT_0
	--> if (tp->ecn_flags & TCP_ECN_DEMAND_CWR)
		tcp_hdr(skb)->ece = 1;

tcp_ack (B)
-->tcp_ecn_rcv_ecn_echo
	--> if (th->ece && !th->syn && (tp->ecn_flags & TCP_ECN_OK))
	    	flag |= FLAG_ECE;
	-->tcp_try_to_open
		-->  if (flag & FLAG_ECE)
			tcp_enter_cwr(sk);
			-->tcp_init_cwnd_reduction
				-->tcp_ecn_queue_cwr
					--> if (tp->ecn_flags & TCP_ECN_OK)
						   tp->ecn_flags |= TCP_ECN_QUEUE_CWR;

tcp_transmit_skb (B)
-->tcp_ecn_send
	--> INET_ECN_xmit
		--> inet_sk(sk)->tos |= INET_ECN_ECT_0
	--> if (tp->ecn_flags & TCP_ECN_QUEUE_CWR) {
		tp->ecn_flags &= ~TCP_ECN_QUEUE_CWR;
	  	tcp_hdr(skb)->cwr = 1;
	    }

tcp_data_queue (A)
--> tcp_ecn_accept_cwr
	--> if (tcp_hdr(skb)->cwr)
		tp->ecn_flags &= ~TCP_ECN_DEMAND_CWR;


13 tcp_fack
14 tcp_fastopen
15 tcp_fastopen_key
16 tcp_fin_timeout
17 tcp_frto
18 tcp_keepalive_intvl
19 tcp_keepalive_probes
20 tcp_keepalive_time
21 tcp_limit_output_bytes
22 tcp_low_latency
23 tcp_max_orphans
The client sends fin, and gets ack, so it is in FIN_WAIT_2, and the server is
in CLOSE_WAIT. At present, if the client exits accidents, then the connection
in client kernel is orphan.
tcp_max_orphans controls the maximum number of orphan connections.
"too many orphaned sockets"

We call tcp_out_of_resources() when retransmit timer or probe timer fires.
tcp_out_of_resources()-->tcp_check_oom()-->tcp_too_many_orphans()

24 tcp_max_syn_backlog

25 tcp_max_tw_buckets
26 tcp_mem
27 tcp_min_tso_segs
28 tcp_moderate_rcvbuf

29 tcp_mtu_probing
30 tcp_no_metrics_save
31 tcp_notsent_lowat
32 tcp_orphan_retries
It controls the retry times for an orphan connection to probe a window update.

33 tcp_reordering
34 tcp_retrans_collapse
35 tcp_retries1
It decides the max retransmit times, if bigger than this limit,
we need to check route table.

36 tcp_retries2
It decides the max retransmit times, if bigger than this limit,
we have to abort.

37 tcp_rfc1337
38 tcp_rmem
39 tcp_sack
This option decides whether we support sack function,
1 : enable
0 : disable
40 tcp_slow_start_after_idle
41 tcp_stdurg
This variable enables or disables RFC 1122 compliance.

42 tcp_synack_retries
43 tcp_syncookies
44 tcp_syn_retries
It decides how many times that a syn packet should be retransmitted. 

45 tcp_thin_dupack
46 tcp_thin_linear_timeouts
47 tcp_timestamps
This option decides whether we support tcp timestamp function,
1 : enable
0 : disable

48 tcp_tso_win_divisor
49 tcp_tw_recycle
It decides whether we enable SO_REUSEADDR

50 tcp_tw_reuse

51 tcp_window_scaling
This option decides whether we support window scale option,
1 : enable
0 : disable

52 tcp_wmem
53 tcp_workaround_signed_windows
